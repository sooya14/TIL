# 알고리즘 01 | 191812

교수님 

이혜진 hjinny@daum.net => 보충 필요하면 오늘안에 메일로 신청하기 (IM 대비)

기본과정 : IM 수준 

B 형은 파이썬이 지원되지 않는다. 

---



## 01_알고리즘

알고리즘

* 어떤 일을 하는데에 있어서의 절차나 과정 

* 유한한 단계 => 반드시 끝이 나야한다. 시작과 끝이 있다. 
* 방법 2가지 
  1. 슈더코드(Pseugo-code) == 의사코드 
     * 언어적으로 완벽하게 구현된 것이 아니라 알고리즘을 설명하기 위해 사용하는 것이다. 
     * 프로그램이 어떻게 동작하는지만 알려주면 된다. 
  2. 순서도 
     * 간단한 알고리즘은 순서도가 더 보기 좋다. 
     * 그러나 문제가 어려워서 길어지게 되면 오히려 복잡해진다. \



좋은 알고리즘이란?

* 적확성 :  문제를 정확하게 해결해야한다. 
* 작업량 : 연산의 횟수가 좋은 알고리즘이다.  
* 메모리 사용량 
  * 요즘에는 크게 문제가 되지 않는다. 
  * 메모리가 중요한 경우는 시스템 소트프 웨어 쪽도 메모리 사용을 많이 사용할 수 있다. 
* 단순성 
  * 가능한 단순하게 봐서 이해가 쉽게 되는 것이 바람직하다. 
  * 단순하게 작성한것이 작업량도 적고 오류 발생도 적다. 
* 최적성: 

=> 수업은 정확성과 작업량에 초점을 맞춘다. 



알고리즘의 성능 

* 시간복잡도 (Time Complexity)

  * 같은 실행환경에서 두개의 프로그램을 돌리면 상관없는데, 그렇지 않으면 약간 객관적이지 않다. 

  * 그렇기 때문에 실행되는 명령문의 개수를 계산하는 것이 더욱 바람직하다. 

  * 표현방법 (n = 입력갯수 )

    1. 0(n) = n제곱 => 수업시간에는 big Oh 만 다룬다. 
       * 상수항 계수 없애서 표현한다. 
       * 다항일 경우는 차수가 가장 높은 것으로 표현 
    2. Ω (n)
    3. Θ (n)

    

## 02_배열

Python 

* 객체지향 언어 
* C 와 java 의 배열과 다른 부분이 있다. 
* list 에 append 연산을 하면 속도가 느리다. 그래서 가능하면 append 가 짜기는 쉬울 수 있지만 배열의 크기를 크게 잡고 index 값을 늘려주면서 하는 방법으로 처리하는 것이 속도를 향상시킬 수 있는 방법이다. 
* 대용량 데이터를 전제해서 만들어졌다. 

C 

* 객체지향 언어가 아니다. 



배열의 필요성

* list 와 배열은 좀 다르지만 list 로 생각하고 보기 
* 수업은 list 만 가지고 한다. 



#### 언어 Interpreter & Compiler

1. Interpreter 방식 (인터프리너 언어)

   * Python

   * complie 과정이 없다. 
   * 바로 run 시키면 실행이 되서 결과를 보여준다. 
   * 실행하는데 속도가 compiler 보다 느리다. 
   * script 언어 
     * 특정 목적에 맞춰져서 만들어진 언어 ex) 자바 스크립트 

   

2. Compiler 방식  

   * C, C++, Java

   * 프로그램을 작성을 했을 때 comlpie & link 과정이 있다. 
   * complie 을 하면 object code 가 만들어지고 link 하면 `.exe`, `.dll` 같은 파일이 생성된다. (Java 면 class 가 생성된다. )
   * 이 파일을 사용자가 사용할 때 운영 체제가 연결되어 실행을 시키는 것이다. 
   * 사용하는 변수들을 미리 선언하고 선언한 변수들을 선언한 데이트 타입으로 짜야지만 실행이 된다. 
   * 모든 분야에 적용할 수 있게 설계된 언어이다. 



#### 1차원 배열 



#### Baby-gin Game

1. 완전 검색 기법 (== Brute-force)

   * 생각할 수 있는 모든 경우의 수를 나열하고 확인해보는 방법
   * 우선 문제를 접할 때 완전 검색 기법을 먼저 시도하는 것이 좋다. 놓치는 경우를 없게 하기 위해서. 
   * 속도는 느리지만 답은 100프로 찾아낼 수 있다. 

   

2. 탐욕적 기법 

   * 근시안적안 방법 
   * 현재상태에서 가장 최적이라고 생각하는 것을 찾는다. 그 다음에 그 값을 선택해서 그것의 나머지 부분에서 최적의 값을 찾고 이것을 반복한다. 
   * 인간이 생각하는 방법이 대부분 탐욕적 기법이긴 하다. 

   

## 03_ 정렬 

* 키 값을 가지고 정렬을 해준다. 

* 실제 업무에 적용을 할 때는 키 값을 가지고 레코드 단위로 움직이게 된다. 

  => ex) 학생정보라고 하면 학번, 학년 등을 정렬하게 된다. 여기서 키 값이 학번이나 학년 등이다. 

  

#### 종류 (6가지) 

=> 모두 다 수업시간에 다룬다.

* 버블 정렬 
  *  가장 기본적이고 쉽게 구현할 수 있는 알고리즘이다. 
  * 그러나 실제로 작 적용하지는 않는다. 
  * 시간 복잡도가 n 제곱이 나온다. => 선택이나 삽입이랑 똑같은데도 잘 사용하지 않는 이유는 버블 정렬은 두가지에 비해 비교, 교환, 횟수가 적다.
  * 인접해 있는 두개의 원소를 비교하면서 크기가 클 경우를 뒤에 보내는 방법 => 제일 큰 숫자가 제일 뒤로 배치를 시킨다. 
* 카운팅 정렬 
  * 많이 사용하지는 않는다. 
  * 특정한 경우에 효과적으로 쓸 수가 있다. 
  * 키가 되는 값이 정수이거나 정수로 표현될 수 있는 경우에 사용한다. 
  * 데이터의 범위가 어느정도인지 알아야지만 적용이 가능하다. 
  * 
  * 









