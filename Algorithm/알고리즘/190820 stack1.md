# Stack 1 | 190820



특성

* 선형구조: 일렬로 저장되는 형태
  * 비서형구조 : 자료와 자료간의 관계를 표현할 때 그림으로 그렸을 때 일렬이 아니라 1대 다 의 형태이다. 



스택에 저장되어 있는 데이터가 얼마나 되는지 알아야한다. 

가장 끝에 위치한 정보 == top



연산

* push : 넣는 연산 => push 를 할 때마다 top 의 값도 바뀐다. 

* pop : 제일 끝에 있는 자료를 삭제하는 것 / 꺼내서 제거를 해준다. 
* peek : 스택 안에서 제거되지는 않는다. 값이 얼마인지 그냥 확인하는 정도 



`pop`

* 데이터가 없을 때 pop 할 수는 없다. => underflow
* len 확인을 해야한다.

`peek`

```python
def peek():
	if len(s) == 0:
        return
    else:
		return s[-1]
```



고려사항 

* `append` 를 사용하면 속도가 느려진다. 



### 

---

### Memoization

* 어딘가에 저장을 하는데 배열이나 값에 기록을 하는 것 
* 다이나믹 프로그래밍 == 동적 계획법 



### DP

* 알고리즘 문제
  * 결정의 문제 : 문제가 주어졌을 때 y/n 로 대답할 수 있는 문제 
    * ex 미로를 통과할 수 있는지 
  * 최적화 문제 : 
    * ex 미로를 어떻게 해야 짧게 통과 할 수 있는지 



* 동적 계획법이 문제를 작게 분활 해서 해결한 것을 추합해서 최종적으로 문제를 해결하는 알고리즘 
* 그리드 알고리즘 : 현재 상탱서 최적이라고 생각되는 값을 서택하고 나머지 문제에 대해서 최적의 값이라고 생각되는 것을 선택하고... 
  * 알고리즘으로 그 문제가 정확하게 해결이 되는지를 확인해야한다. 
* 동적 계획법 :
  * 속도와 성능에서는 그리드 알고리즘 보다 떨어진다. 
  * 추합해서 결과 수정하고 하면서 하기 때문에 



* ad 에서는 재귀호출을 사용해야한다. im은 ㄴㄴ 



* 그래프 
  * 완전 그래프 
    * 모든 점선들이 다 연결된 그래프 
  * 부분 그래프



* 인접 
  * 두개의 정점 사이에 열결되어 있는 것 



그래프 표현 

* 



## 응용 

* 인접행렬의 단점 
  * 메모리 낭비를 많이 한다. 
  * 인접 행렬이 간선행렬에 비해서 메모리 용량을 많이 소요한다. 그러나 간선배열이 찾기가 쉽지 않다. => 구현이 복잡해진다. 





## 그래프 탐색 



### DFS 깊이우선탐색

* 하나 선택해서 시작점을 기점으로 해서 하나씩 무조건 쭉 따라간다. 
* 구현 방식이 stack 이다. 
* 더이상 갈 수 없을 때 마지막 간선으로 되돌아 가서 다시 또 가볼때가 있는지 찾아보고 ... 
* 알고리즘 
  1. 시작 정점 v 를 결정하여 방문
  2. 정점  v 에 인접한 정점 중에서 
     1. 방문하지 않은 정점 w 가 있으면 정점 v 를 스택에 정점 w 를 방문한다. 그리고 w 를v 로 하여 다시 2 를 반복한다. 
     2. 방문하지 않은 정점이 없으면  탐색의 방향을 바꿎기 위해서 스택을 pop 하여 밭은 가장 마지막 방문 정점을 v 로 하여 다시 2 반복 







### BFS 너비 우선 탐색

* 하나정점에 열결 되어 있는 것을 다 가본다. 







