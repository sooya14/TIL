# List 2 | 190814



## 01_2차원 배열 

시험은 보통 2차원 배열로 풀어야하는 문제가 나온다. 



### 01) 배열 순회 

*  `len(array)` => 행의 갯수 
* `array[i][j] `=> 앞에가 행 뒤에가 열 
* 지그재그 순회 
  * m = 열의 크기 / 예시에서는 4가 된다. 
  * (i %2 가 1일 경우에는) 짝수일경우는 감소하게 진행... 헷갈리면 if 사용해서 짝수일때랑 홀 수 일때를 나눠서 생각  



* ☆ 델타 이용한 2차 배열 탐색 
  * 예시에서 mode 가이라 대문가 I 로 변경해야한다. 
  * 현재 위치가 x, y 라고 했을 때 방향에 맞춰서 



* 전치 행렬 
  * 자리 바꿈 할 때 사용 
  * 정사각형이어야지 대칭이 된다. 
  * 대각선 기준으로 값을 교환하게 한다. 
  * if 는 왜 들어갔을 까?
    * 두번 반복하면 그대로 되니깐 i 가 j 보다 클때만 할 수 있게 한 것이다. 



### 02) 부분집합 합 



#### 비트 연산

* & 
  * bit = 1
* XOR
  * 두개가 다를 때만 True,  같으면 False

* <<
  * 01010110 <<1    = 10101100
  * 밀리면서 앞의 숫자가 짤릴 수 있다. 
  * << n 해주면 * 2 ^ 2 의 효과가 난다. 
* `>>`
  * 011010110 >> 1    0101011
  * `>> n` 은 나누기 2의 n 의 효과를 보여준다. 



## 02_검색

### 01) 순차검색

* 원하는 값이 없으면 끝까지 간다. 
* 정렬리 되어 있지 않은 경우는 무조건 끝까지 간다. 
* 배열의 크기가 클 경우에는 효율이 떨어진다.



### 02) 이진 검색

* 정렬이 되어 있으면 하나 찍어서 보고 그 값보다 크면 앞을 찾아보면 된다. 

* 정렬이 되어 있는 상태여야지만 검색이 가능하다. 

* 과정 

  1. 중앙에 있는 것을 찍어본다. 
  2. 가운데 값이 찾고자 하는 값보다 작으면 앞을 찾아보고 아니면 뒤쪽을 찾아보면 된다. 

* 복잡한 문제일수록 재귀함수로 구현하는 것이 알고리즘을 기술하는 것이 훨씬 편하다. 

* ad 레벨부터는 대부분 재귀로 풀어야한다. 

  

  ex) [2, 4, 7, 9, 11] 에서 20을 찾는 경우 => 재귀함수 

  ```pyth
  bins(a, 0, 6, 7)
  ```

  

### 03) 셀렉션 알고리즘 

* 정렬이 되어 있는 상태에서 k 번째 값을 찾아준다. 
* 